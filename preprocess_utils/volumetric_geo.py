import trimesh
import numpy as np
from scipy.sparse import csr_matrix
from scipy.sparse.csgraph import dijkstra

# This implementation is a straightforward (and relatively naive) approach.
# For large meshes or many bones, it is slow thst is why we precompute it.
# Also, tol_ratio is a parameter that needs to be tuned.
# The idea is as follows:
# For each bone (with a given 3D position), we want to “shoot” rays from the bone to each vertex and decide whether that vertex is directly visible from the bone.
# We do this using a ray–mesh intersection test (using the trimesh library).
# If the first intersection (along the ray) occurs at a distance nearly equal to the Euclidean distance from the bone to the vertex,
# then the vertex is considered visible and its geodesic distance is simply that Euclidean distance.
# For vertices that are not directly visible (occluded), we assume that the true volumetric geodesic distance is the sum of two components:
# - A surface geodesic distance from that vertex to the nearest visible vertex.
# - Plus the Euclidean (interior) distance from the bone to that visible vertex.
# We build a surface graph of the mesh (where nodes are vertices and edges are weighted by the Euclidean distance between connected vertices)
# and use Dijkstra’s algorithm to compute the shortest path (surface geodesic) distances between vertices.
# TODO: The computation of the surface geodesic distances should be reused from the result generated by the surface_geo.py file as it is double work.

def build_mesh_graph(vertices, faces):
    """
    Build a sparse graph from the mesh surface.
    Each edge between vertices that share a face is weighted by the Euclidean distance.

    Parameters:
        vertices (np.ndarray): (N, 3) array of vertex positions.
        faces (np.ndarray): (M, 3) array of face indices.

    Returns:
        graph (csr_matrix): Sparse matrix of shape (N, N) with edge distances.
    """
    N = vertices.shape[0]
    # Build a set of unique edges from faces.
    edges = set()
    for face in faces:
        edges.add(tuple(sorted((face[0], face[1]))))
        edges.add(tuple(sorted((face[1], face[2]))))
        edges.add(tuple(sorted((face[2], face[0]))))
    edges = np.array(list(edges))
    # Compute Euclidean distances for each edge.
    dists = np.linalg.norm(vertices[edges[:,0]] - vertices[edges[:,1]], axis=1)
    # Build a sparse matrix.
    graph = csr_matrix((dists, (edges[:,0], edges[:,1])), shape=(N, N))
    # Make the graph undirected.
    graph = graph + graph.T
    return graph

def compute_volumetric_geodesic_single(vertices, faces, bone_position, tol_ratio=1e-3):
    """
    Compute volumetric geodesic distances from a single bone to all vertices.
    For each vertex, if the ray from the bone to the vertex is unobstructed (i.e. the first intersection
    is nearly at the vertex), then the distance is the Euclidean distance.
    Otherwise, we find the nearest visible vertex on the surface (using a surface geodesic computed
    over the mesh graph) and add the Euclidean distance from the bone to that visible vertex.

    Parameters:
        vertices (np.ndarray): (N, 3) array.
        faces (np.ndarray): (M, 3) array.
        bone_position (np.ndarray): (3,) array.
        tol_ratio (float): Tolerance ratio for visibility check.

    Returns:
        geo (np.ndarray): (N,) array of geodesic distances.
    """
    N = vertices.shape[0]
    mesh = trimesh.Trimesh(vertices=vertices, faces=faces, process=False)

    # Compute vectors and Euclidean distances from bone to each vertex.
    vecs = vertices - bone_position  # (N, 3)
    euclidean_dists = np.linalg.norm(vecs, axis=1)  # (N,)

    # Normalize directions.
    directions = vecs / (euclidean_dists[:, None] + 1e-8)

    # Cast rays from the bone toward each vertex.
    ray_origins = np.tile(bone_position, (N, 1))
    # Using trimesh's ray intersector:
    # intersects_first returns the distance along the ray of the first hit.
    first_hits = mesh.ray.intersects_first(ray_origins, directions)  # (N,)

    # Determine visible vertices: if the first hit distance is close to the Euclidean distance.
    visible = np.abs(first_hits - euclidean_dists) < (tol_ratio * euclidean_dists)

    # Initialize geodesic distances.
    geo = np.empty(N, dtype=np.float32)
    geo[visible] = euclidean_dists[visible]

    # For invisible vertices, compute the surface geodesic distance to the nearest visible vertex.
    # This here is double work as I already compute the surface geodesic distance in the surface_geo.py file.
    # The code was written before I copied and commented https://github.com/zhan-xu/RigNet/blob/master/geometric_proc/common_ops.py.
    # TODO: Use the resulting matrix of surface_geo.py.
    if not np.all(visible):
        # Build surface graph.
        graph = build_mesh_graph(vertices, faces)
        vis_idx = np.where(visible)[0]
        if len(vis_idx) == 0:
            # No visible vertices: fallback to Euclidean distance.
            geo[~visible] = euclidean_dists[~visible]
        else:
            # Compute shortest surface distances from all visible vertices.
            dist_matrix = dijkstra(csgraph=graph, indices=vis_idx, directed=False)
            # For each invisible vertex, find the minimum surface distance from any visible vertex.
            # dist_matrix has shape (num_visible, N).
            surface_dist = dist_matrix.min(axis=0)  # (N,)
            # For each invisible vertex, also get the Euclidean distance from the bone to the best visible vertex.
            # To approximate this, we can compute for each invisible vertex:
            #   geo = min_{j in vis_idx} (surface_distance(i, j) + euclidean_dists[j])
            # For simplicity, we recompute per vertex:
            for i in np.where(~visible)[0]:
                candidate = dist_matrix[:, i] + euclidean_dists[vis_idx]
                geo[i] = candidate.min()
    return geo

def compute_volumetric_geodesic(vertices, faces, bone_positions, tol_ratio=1e-3):
    """
    Compute a volumetric geodesic distance matrix between all vertices and all bones.

    Parameters:
       vertices (np.ndarray): (N, 3)
       faces (np.ndarray): (M, 3)
       bone_positions (np.ndarray): (B, 3)
       tol_ratio (float): Tolerance for visibility check.

    Returns:
       geo_matrix (np.ndarray): (N, B) matrix where geo_matrix[i, j] is the geodesic distance from bone j to vertex i.
    """
    N = vertices.shape[0]
    B = bone_positions.shape[0]
    geo_matrix = np.empty((N, B), dtype=np.float32)
    for j in range(B):
        geo_matrix[:, j] = compute_volumetric_geodesic_single(vertices, faces, bone_positions[j], tol_ratio)
    return geo_matrix